* Ractors are Ruby's goroutines

* System threads - they are smart

* Goroutines - they are genius

* Ruby before 3.0

It is, well, quite straightforward...

* Introducing GVL!

a.k.a. Global Virtual machine Lock
a.k.a. Global Interpreter Lock (GIL)
a.k.a. /(coming in a few slides)/

* Three questions

- Why the race condition happened despite the lock and despite using only one core?
- Why MRI produced a race condition only after a seemingly innocent refactoring?
- Why on Earth do we need GVL at all if it doesn't protect us from race conditions?

* Parallelism ≠ Concurrency

* Parallelism ≠ Concurrency


   *First thread*: =0, 1, 2, 3, ... , 99=  /counting numbers/

   *Second thread*: ~A, B, C, D, ..., Z~   /counting letters/

* Parallelism ≠ Concurrency

   Parallel: ❌
   Concurrent: ❌

   +---------------------------------------------------------------+
   |             |                                                 |
   | CPU Core #0 | 0, 1, 2, ..., 97, 98, 99, A, B, ..., X, Y, Z    |
   |             |                                                 |
   +---------------------------------------------------------------+
   |             |                                                 |
   | CPU Core #1 |                                                 |
   |             |                                                 |
   +---------------------------------------------------------------+


   |========================== Timeline ===========================>


* Parallelism ≠ Concurrency

   Parallel: ✔️
   Concurrent: ✔️

   +---------------------------------------------------------------+
   |             |                                                 |
   | CPU Core #0 | 0, 1, 2, 3, 4, 5, ..., 97, 98, 99               |
   |             |                                                 |
   +---------------------------------------------------------------+
   |             |                                                 |
   | CPU Core #1 | A, B, C, D, E, F, ..., X, Y, Z                  |
   |             |                                                 |
   +---------------------------------------------------------------+


   |========================== Timeline ===========================>

* Parallelism ≠ Concurrency

   Parallel: ❌
   Concurrent: ✔️

   +---------------------------------------------------------------+
   |             |                                                 |
   | CPU Core #0 | 0, A, 1, 2, B, C, ..., X, 25, 26, Y, Z, ..., 99 |
   |             |                                                 |
   +---------------------------------------------------------------+
   |             |                                                 |
   | CPU Core #1 |                                                 |
   |             |                                                 |
   +---------------------------------------------------------------+


   |========================== Timeline ===========================>


* Race conditions, context switching and Ruby GVL

* Veeqo, Veeqo AMazon

* +Global+ Great Virtual machine Lock

Because it is not global anymore!

a.k.a. GVL

pre Ruby 3.0:
GVL = Global Interpreter Lock (GIL) = Global Virtual machine Lock

Ruby 3.0+:
GVL = a.k.a. Great Virtual machine Lock

* M:M vs M:N

Here create just _one_ Ractor and show how two CPU cores are filled.
If needed reduce the cores to two just to fill them up to 100%.

M:N -- finally an alternative to forking which is hugely expensive memory-wise!

* How to contact me (and why)

* Why Ractors matter

Because many Ruby developers are now exposed to Go, voluntarily or not
